#!/usr/bin/python

import sys
import uuid
import readline
import cmd2
import json
from vnc_api import vnc_api
from res_identifier import res_identifier
from res_type import res_type

config_env = {
    'auth-username' : 'admin',
    'auth-password' : 'contrail123',
    'auth-tenant' : 'admin',
    'auth-region' : 'RegionOne',
    'auth-server' : '127.0.0.1',
    'api-server' : '127.0.0.1',
    'tenant' : 'demo',
    'format' : 'json'}


class Edit(object):
    def __init__(self):
        self.mode = False
        self.name = None
        self.obj = None
        self.res = None
        self.uuid = None
        self.update = False
        self.type = [''] * 64

class Config(cmd2.Cmd):
    def __init__(self):
        cmd2.Cmd.__init__(self)
        readline.set_completer_delims(' ')
        self.vnc = vnc_api.VncApi(
                username = config_env['auth-username'],
                password = config_env['auth-password'],
                tenant_name = config_env['auth-tenant'],
                api_server_host = config_env['api-server'],
                auth_host = config_env['auth-server'])

        try:
            self.tenant = self.vnc.project_read(
                    fq_name = ['default-domain', config_env['tenant']])
            self.prompt = '%s# ' %(self.tenant.name)
        except:
            self.tenant = None
            self.prompt = '/# '
        self.edit = Edit()

    def do_env(self, args):
        if not args:
            return
        arg_list = args.split(' ')
        if not config_env.has_key(arg_list[0]):
            print 'ERROR: No env %s!' %(arg_list[0])
            return
        config_env[arg_list[0]] = arg_list[1]

    def prompt_op(self):
        if self.tenant:
            self.prompt = '%s# ' %(self.tenant.name)
        else:
            self.prompt = '/# '

    def prompt_edit(self, name = None):
        self.prompt = 'edit# '

    def do_tenant(self, name):
        if name == '/':
            self.tenant = None
        else:
            try:
                self.tenant = self.vnc.project_read(
                        fq_name = ['default-domain', name])
            except Exception as e:
                print 'ERROR: %s' %(str(e))
        self.prompt_op()

    def res_list_get(self, name):
        func_name = name.replace('-', '_')+'s_list'
        func = getattr(self.vnc, func_name)
        res_list = func()[name + 's']
        name_list = []                                        
        for res in res_list:                                  
            name_str = ''                                     
            for i in res['fq_name']:                          
                name_str += '%s:' %(i)                        
            name_list.append(name_str.rstrip(':'))            
        return name_list                                      

    def res_obj_get(self, res, name):
        func_name = res.replace('-', '_')+'_read'             
        func = getattr(self.vnc, func_name)                   
        obj = func(fq_name = name.split(':'))                 
        return obj

    def show_res_list(self, name):                            
        for res in self.res_list_get(name):                   
            print res

    def show_res_obj(self, res, name):                        
        obj = self.res_obj_get(res, name)
        if config_env['format'] == 'dump':
            obj.dump()
        else:
            print json.dumps(obj, default = self.vnc._obj_serializer_all,
                    indent=4, separators=(',', ': '))
                                                              
    def show_op(self, args):                                  
        arg_list = args.split(' ')                            
        if len(arg_list) == 1:                                
            self.show_res_list(arg_list[0])                   
        elif len(arg_list) == 2:                              
            self.show_res_obj(arg_list[0], arg_list[1])       
        else:                                                 
            print 'ERROR: too many arguments!'                 
                                                              
    def show_edit(self, args):                                
        if not self.edit.obj:
            print 'name: %s' %(self.edit.name)
            return
        if config_env['format'] == 'dump':
            self.edit.obj.dump()
        else:
            print json.dumps(self.edit.obj,                       
                    default = self.vnc._obj_serializer_all,       
                    indent=4, separators=(',', ': '))             
                                                              
    def do_show(self, args):                                  
        if self.edit.mode:                                         
            self.show_edit(args)                              
        else:
            self.show_op(args)

    def complete_res_name(self, text, line):
        #print 'complete: %s, %s, %s, %s' %(text, line, begidx, endidx)
        arg_list = line.split(' ')
        arg_count = len(arg_list) - 1
        list_all = []
        if arg_count ==1:
            list_all = res_identifier.keys()
        elif arg_count == 2:
            list_all = self.res_list_get(arg_list[1])
        if not text:
            completions = list_all
        else:
            completions = [ i for i in list_all if i.startswith(text) ]
        return completions

    def complete_show(self, text, line, begidx, endidx):
        return self.complete_res_name(text, line)

    def edit_obj_create(self, res, name):
        obj_class = getattr(vnc_api, res_identifier[res]['class-name'])
        if (name == 'uuid'):
            self.edit.uuid = str(uuid.uuid4())
        if res_identifier[res]['parent'] and \
                (len(res_identifier[res]['parent']) > 1):
            # If the resource has mulitple parents, the object will be
            # created when parent is set.
            obj = None
        else:
            if (name == 'uuid'):
                obj = obj_class(name = self.edit.uuid)
            else:
                obj = obj_class(name = name)
        return obj

    def do_edit(self, args):
        if self.edit.mode:
            print 'Already in edit mode.'
            return
        arg_list = args.split(' ')
        if not res_identifier.has_key(arg_list[0]):
            print 'ERROR: Resource %s does not exist!' %(arg_list[0])
            return
        if len(arg_list) > 1:
            try:
                self.edit.obj = self.res_obj_get(arg_list[0], arg_list[1])
                self.edit.update = True
            except:
                self.edit.obj = self.edit_obj_create(arg_list[0], arg_list[1])
                self.edit.update = False
        self.edit.res = arg_list[0]
        self.edit.name = arg_list[1]
        self.edit.mode = True
        self.prompt_edit()

    def complete_edit(self, text, line, begidx, endidx):
        return self.complete_res_name(text, line)

    def do_commit(self, args):
        if not args:
            if self.update:
                print 'Object is updated.'
            else:
                print 'Object is created.'
        else:
            if self.update:
                print 'Object is not updated.'
            else:
                print 'Object is not created.'
        self.edit = False
        self.prompt_op()

    def attr_list_get(self, obj):
        attr_list = []
        for i in dir(obj.__class__):
            if i.startswith('set'):
                attr_list.append(i.replace('set_', ''))
        return attr_list

    def set_parent(self, parent_name):
        parent_fq_name = parent_name.split(':')
        func_str = self.edit_obj.parent_type.replace('-', '_') + '_read'
        func = getattr(self.vnc, func_str)
        try:
            parent = func(fq_name = parent_fq_name)
            self.edit_obj.fq_name = list(parent.fq_name)
            self.edit_obj.fq_name.append(self.edit_obj.name)
        except:
            print 'EXCEPT: Read parent %s!' %(parent_name)

    def is_attr_val(self, obj, attr_name):
        attr = getattr(obj.__class__, attr_name, [])
        if not attr:
            return False
        doc = inspect.getdoc(attr)
        if not doc.split('returns: ')[1].startswith('xsd'):
            return False
        return True

    def set_attr_val(self, obj, attr_name, attr_val):
        func = getattr(obj.__class__, 'set_' + attr_name)
        func(obj, attr_val)
        return True

    def set_ref(self, res_type, res_name):
        pass

    def do_set(self, args):
        if not self.edit:
            return
        arg_list = args.split(' ')
        self.edit_obj_cur = self.edit_obj
        if (arg_list[0] == 'parent'):
            self.set_parent(arg_list[1])
        elif self.set_attr_val(arg_list[0], arg_list[1]):
            return
        elif self.set_ref(arg_list[0], arg_list[1]):
            return

    def complete_set(self, text, line, begidx, endidx):
        arg_list = line.split(' ')
        arg_count = len(arg_list) - 1
        list_all = []
        res = res_identifier[self.edit.res]
        if arg_count == 0:
            return
        elif arg_count == 1:
            # Identifier properites and references.
            list_all = res['property'].keys() + res['reference'].keys()
            list_all.append('parent')
        elif arg_list[1] in res['property'].keys():
            type_name = res['property'][arg_list[1]]['type']
            for arg in arg_list[2:arg_count]:
                type_name = res_type[type_name]['member'][arg]['type']
            if not type_name.startswith('xsd'):
                list_all = res_type[type_name]['member'].keys()
        elif arg_list[1] in res['reference'].keys():
            if arg_count == 2:
                list_all = self.res_list_get(arg_list[1])
            elif arg_count == 3:
                ref = res['reference'][arg_list[1]]
                if ref.has_key('attr'):
                    list_all = res_type[ref['attr']]['member'].keys()
            elif arg_count >= 4:
                ref = res['reference'][arg_list[1]]
                type_name = res_type[ref['attr']]['member'][arg_list[3]]['type']
                for arg in arg_list[4:arg_count]:
                    type_name = res_type[type_name]['member'][arg]['type']
                if not type_name.startswith('xsd'):
                    list_all = res_type[type_name]['member'].keys()

        if not text:
            completions = list_all
        else:
            completions = [ i for i in list_all if i.startswith(text) ]
        return completions


if __name__ == '__main__':                                    
    Config().cmdloop()

